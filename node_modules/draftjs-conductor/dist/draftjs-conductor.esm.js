// @flow
import React from 'react';
import { EditorState, Modifier, convertToRaw, convertFromRaw, ContentState } from 'draft-js';

// Default maximum block depth supported by Draft.js CSS.
/*:: import type { BlockNode } from "draft-js/lib/BlockNode.js.flow";*/
var DRAFT_DEFAULT_MAX_DEPTH = 4;

// Default depth class prefix from Draft.js CSS.
var DRAFT_DEFAULT_DEPTH_CLASS = "public-DraftStyleDefault-depth";

/**
 * Generates CSS styles for list items, for a given selector pattern.
 * @param {string} selectorPrefix
 * @param {number} minDepth
 * @param {number} maxDepth
 */
var generateListNestingStyles = function generateListNestingStyles(selectorPrefix /*: string*/, minDepth /*: number*/, maxDepth /*: number*/) {
  var styles = "";

  for (var depth = minDepth; depth <= maxDepth; depth++) {
    var prefix = "" + selectorPrefix + depth;
    var counter = "ol" + depth;
    var margin = 1.5 * (depth + 1);

    styles += "\n." + prefix + ".public-DraftStyleDefault-listLTR { margin-left: " + margin + "em; }\n." + prefix + ".public-DraftStyleDefault-listRTL { margin-right: " + margin + "em; }\n." + prefix + ".public-DraftStyleDefault-orderedListItem::before { content: counter(" + counter + ") '. '; counter-increment: " + counter + "; }\n." + prefix + ".public-DraftStyleDefault-reset { counter-reset: " + counter + "; }";
  }

  return styles;
};

/**
 * Dynamically generates the right list nesting styles.
 * Pure component - will only re-render when `max` changes (eg. never).
 */
var ListNestingStyles = function ListNestingStyles(props /*: { max: number }*/) {
  var max = props.max;

  var min = DRAFT_DEFAULT_MAX_DEPTH + 1;

  return max > DRAFT_DEFAULT_MAX_DEPTH ? React.createElement(
    "style",
    null,
    generateListNestingStyles(DRAFT_DEFAULT_DEPTH_CLASS, min, max)
  ) : null;
};

/**
 * Add depth classes that Draft.js doesn't provide.
 * See https://github.com/facebook/draft-js/blob/232791a4e92d94a52c869f853f9869367bdabdac/src/component/contents/DraftEditorContents-core.react.js#L58-L62.
 * @param {ContentBlock} block
 */
var blockDepthStyleFn = function blockDepthStyleFn(block /*: BlockNode*/) {
  var depth = block.getDepth();
  return depth > DRAFT_DEFAULT_MAX_DEPTH ? "" + DRAFT_DEFAULT_DEPTH_CLASS + depth : "";
};

/*:: import type { ElementRef } from "react";*/
/*:: import type { Editor, EditorState as EditorStateType } from "draft-js";*/


var getFragmentFromSelection = require("draft-js/lib/getFragmentFromSelection");

// Custom attribute to store Draft.js content in the HTML clipboard.
var FRAGMENT_ATTR = "data-draftjs-conductor-fragment";

/**
 * Overrides the default copy/cut behavior, adding the serialised Draft.js content to the clipboard data.
 * See also https://github.com/basecamp/trix/blob/62145978f352b8d971cf009882ba06ca91a16292/src/trix/controllers/input_controller.coffee#L415-L422
 * We serialise the editor content within HTML, not as a separate mime type, because Draft.js only allows access
 * to HTML in its paste event handler.
 */
var draftEditorCopyListener = function draftEditorCopyListener(ref /*: ElementRef<Editor>*/, e /*: Event & {
                                                                                                   clipboardData: DataTransfer,
                                                                                                 }*/) {
  var selection = window.getSelection();
  // Get clipboard content like Draft.js would.
  // https://github.com/facebook/draft-js/blob/37989027063ccc8279bfdc99a813b857549512a6/src/component/handlers/edit/editOnCopy.js#L34
  var fragment = getFragmentFromSelection(ref._latestEditorState);

  // Override the default behavior if there is a selection, and content, and clipboardData is supported (IE11 is out).
  if (selection.rangeCount > 0 && fragment && e.clipboardData) {
    var content = ContentState.createFromBlockArray(fragment.toArray());
    var serialisedContent = JSON.stringify(convertToRaw(content));

    // Create a temporary element to store the selectionâ€™s HTML.
    // See also Rangy's implementation: https://github.com/timdown/rangy/blob/1e55169d2e4d1d9458c2a87119addf47a8265276/src/core/domrange.js#L515-L520.
    var fragmentElt = document.createElement("div");
    // Modern browsers only support a single range.
    fragmentElt.appendChild(selection.getRangeAt(0).cloneContents());
    fragmentElt.setAttribute(FRAGMENT_ATTR, serialisedContent);
    // We set the style property to replicate the browser's behavior of inline styles in rich text copy-paste.
    // In Draft.js, this is important for line breaks to be interpreted correctly when pasted into another word processor.
    // See https://github.com/facebook/draft-js/blob/a1f4593d8fa949954053e5d5840d33ce1d1082c6/src/component/base/DraftEditor.react.js#L328.
    fragmentElt.setAttribute("style", "white-space: pre-wrap;");

    e.clipboardData.setData("text/plain", selection.toString());
    e.clipboardData.setData("text/html", fragmentElt.outerHTML);

    e.preventDefault();
  }
};

var registerCopySource = function registerCopySource(ref /*: ElementRef<Editor>*/) {
  var editorElt = ref.editor;
  var onCopy = draftEditorCopyListener.bind(null, ref);

  editorElt.addEventListener("copy", onCopy);
  editorElt.addEventListener("cut", onCopy);

  return {
    unregister: function unregister() {
      editorElt.removeEventListener("copy", onCopy);
      editorElt.removeEventListener("cut", onCopy);
    }
  };
};

/**
 * Handles pastes coming from Draft.js editors set up to serialise
 * their Draft.js content within the HTML.
 * This SHOULD NOT be used for stripPastedStyles editor.
 */
var handleDraftEditorPastedText = function handleDraftEditorPastedText(html /*: ?string*/, editorState /*: EditorStateType*/) {
  // Plain-text pastes are better handled by Draft.js.
  if (html === "" || typeof html === "undefined" || html === null) {
    return false;
  }

  var doc = new DOMParser().parseFromString(html, "text/html");
  var fragmentElt = doc.querySelector("[" + FRAGMENT_ATTR + "]");

  // Handle the paste if it comes from draftjs-conductor.
  if (fragmentElt) {
    var fragmentAttr = fragmentElt.getAttribute(FRAGMENT_ATTR);
    var rawContent = void 0;

    try {
      // If JSON parsing fails, leave paste handling to Draft.js.
      // There is no reason for this to happen, unless the clipboard was altered somehow.
      // $FlowFixMe
      rawContent = JSON.parse(fragmentAttr);
    } catch (error) {
      return false;
    }

    var fragment = convertFromRaw(rawContent).getBlockMap();

    var content = Modifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);
    return EditorState.push(editorState, content, "insert-fragment");
  }

  return false;
};

export { ListNestingStyles, DRAFT_DEFAULT_MAX_DEPTH, DRAFT_DEFAULT_DEPTH_CLASS, generateListNestingStyles, blockDepthStyleFn, registerCopySource, handleDraftEditorPastedText };
