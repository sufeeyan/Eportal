"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const heroku_cli_util_1 = require("heroku-cli-util");
const graphql_1 = require("graphql");
const chalk_1 = __importDefault(require("chalk"));
const git_1 = require("../../git");
const Command_1 = require("../../Command");
const utils_1 = require("../../utils");
const graphqlTypes_1 = require("apollo-language-server/lib/graphqlTypes");
const moment_1 = __importDefault(require("moment"));
const lodash_sortby_1 = __importDefault(require("lodash.sortby"));
const formatChange = (change) => {
    let color = (x) => x;
    if (change.type === graphqlTypes_1.ChangeType.FAILURE) {
        color = chalk_1.default.red;
    }
    if (change.type === graphqlTypes_1.ChangeType.WARNING) {
        color = chalk_1.default.yellow;
    }
    const changeDictionary = {
        [graphqlTypes_1.ChangeType.FAILURE]: "FAIL",
        [graphqlTypes_1.ChangeType.WARNING]: "WARN",
        [graphqlTypes_1.ChangeType.NOTICE]: "PASS"
    };
    return {
        type: color(changeDictionary[change.type]),
        code: color(change.code),
        description: color(change.description)
    };
};
function formatTimePeriod(hours) {
    if (hours <= 24) {
        return hours === 1 ? `${hours} hour` : `${hours} hours`;
    }
    const days = Math.floor(hours / 24);
    return days === 1 ? `${days} day` : `${days} days`;
}
exports.formatTimePeriod = formatTimePeriod;
function formatMarkdown({ checkSchemaResult, serviceName, tag }) {
    const { diffToPrevious } = checkSchemaResult;
    if (!diffToPrevious) {
        throw new Error("checkSchemaResult.diffToPrevious missing");
    }
    const { validationConfig } = diffToPrevious;
    if (!validationConfig) {
        throw new Error("checkSchemaResult.diffToPrevious.validationConfig missing");
    }
    const hours = Math.abs(moment_1.default()
        .add(validationConfig.from, "second")
        .diff(moment_1.default().add(validationConfig.to, "second"), "hours"));
    const breakingChanges = diffToPrevious.changes.filter(change => change.type === "FAILURE");
    return `
### Apollo Service Check
🔄 Validated your local schema against schema tag \'${tag}\' on service \'${serviceName}\'.
🔢 Compared **${diffToPrevious.changes.length} schema changes** against operations seen over the **last ${formatTimePeriod(hours)}**.
${breakingChanges.length > 0
        ? `❌ Found **${diffToPrevious.changes.filter(change => change.type === "FAILURE")
            .length} breaking changes** that would affect **${diffToPrevious.affectedQueries
            ?
                diffToPrevious.affectedQueries.length
            : "no"} operations**`
        : `✅ Found **no breaking changes**.`}

🔗 [View your service check details](${checkSchemaResult.targetUrl}).
`;
}
exports.formatMarkdown = formatMarkdown;
function formatHumanReadable({ checkSchemaResult }) {
    const { targetUrl, diffToPrevious: { changes, validationConfig } } = checkSchemaResult;
    let result = "";
    const failures = changes.filter(({ type }) => type === graphqlTypes_1.ChangeType.FAILURE);
    if (changes.length === 0) {
        result = "\nNo changes present between schemas";
    }
    else {
        const sortedChanges = lodash_sortby_1.default(changes, [
            change => change.code,
            change => change.description
        ]);
        const breakingChanges = sortedChanges.filter(change => change.type === graphqlTypes_1.ChangeType.FAILURE);
        lodash_sortby_1.default(breakingChanges, change => change.type);
        const nonBreakingChanges = sortedChanges.filter(change => change.type !== graphqlTypes_1.ChangeType.FAILURE);
        heroku_cli_util_1.table([
            ...nonBreakingChanges.map(formatChange),
            nonBreakingChanges.length && breakingChanges.length ? {} : null,
            ...breakingChanges.map(formatChange)
        ].filter(Boolean), {
            columns: [
                { key: "type", label: "Change" },
                { key: "code", label: "Code" },
                { key: "description", label: "Description" }
            ],
            printHeader: () => { },
            printLine: line => {
                result += `\n${line}`;
            }
        });
    }
    if (targetUrl) {
        result += `\n\nView full details at: ${targetUrl}`;
    }
    return result;
}
exports.formatHumanReadable = formatHumanReadable;
class ServiceCheck extends Command_1.ProjectCommand {
    async run() {
        const taskOutput = {};
        const breakingChangesErrorMessage = "breaking changes found";
        try {
            await this.runTasks(({ config, flags, project }) => [
                {
                    title: "Checking service for changes",
                    task: async (ctx, task) => {
                        if (!config.name) {
                            throw new Error("No service found to link to Engine");
                        }
                        const tag = flags.tag || config.tag || "current";
                        task.title = `Validating local schema against tag ${chalk_1.default.blue(tag)} on service ${chalk_1.default.blue(config.name)}`;
                        task.output = "Resolving schema";
                        const schema = await project.resolveSchema({ tag });
                        await git_1.gitInfo(this.log);
                        const historicParameters = utils_1.validateHistoricParams({
                            validationPeriod: flags.validationPeriod,
                            queryCountThreshold: flags.queryCountThreshold,
                            queryCountThresholdPercentage: flags.queryCountThresholdPercentage
                        });
                        task.output = "Validating schema";
                        const newContext = {
                            checkSchemaResult: await project.engine.checkSchema(Object.assign({ id: config.name, schema: graphql_1.introspectionFromSchema(schema).__schema, tag: flags.tag, gitContext: await git_1.gitInfo(this.log), frontend: flags.frontend || config.engine.frontend }, (historicParameters && { historicParameters }))),
                            config,
                            shouldOutputJson: !!flags.json,
                            shouldOutputMarkdown: !!flags.markdown
                        };
                        Object.assign(ctx, newContext);
                        Object.assign(taskOutput, ctx);
                        task.title = `Validated local schema against tag ${chalk_1.default.blue(tag)} on service ${chalk_1.default.blue(config.name)}`;
                    }
                },
                {
                    title: "Comparing schema changes",
                    task: async (ctx, task) => {
                        const schemaChanges = ctx.checkSchemaResult.diffToPrevious.changes;
                        const numberOfCheckedOperations = ctx.checkSchemaResult.diffToPrevious
                            .numberOfCheckedOperations || 0;
                        const validationConfig = ctx.checkSchemaResult.diffToPrevious.validationConfig;
                        const hours = validationConfig
                            ? Math.abs(moment_1.default()
                                .add(validationConfig.from, "second")
                                .diff(moment_1.default().add(validationConfig.to, "second"), "hours"))
                            : null;
                        task.title = `Compared ${chalk_1.default.blue(schemaChanges.length.toString())} schema ${schemaChanges.length === 1 ? "change" : "changes"} against ${chalk_1.default.blue(numberOfCheckedOperations.toString())} ${numberOfCheckedOperations === 1 ? "operation" : "operations"}${hours
                            ? ` over the last ${chalk_1.default.blue(formatTimePeriod(hours))}`
                            : ""}`;
                    }
                },
                {
                    title: "Reporting result",
                    task: async (ctx, task) => {
                        const breakingSchemaChangeCount = ctx.checkSchemaResult.diffToPrevious.changes.filter(change => change.type === graphqlTypes_1.ChangeType.FAILURE).length;
                        const nonBreakingSchemaChangeCount = ctx.checkSchemaResult.diffToPrevious.changes.length -
                            breakingSchemaChangeCount;
                        task.title = `Found ${chalk_1.default.blue(breakingSchemaChangeCount.toString())} breaking ${breakingSchemaChangeCount === 1 ? "change" : "changes"} and ${chalk_1.default.blue(nonBreakingSchemaChangeCount.toString())} compatible ${nonBreakingSchemaChangeCount === 1 ? "change" : "changes"}`;
                        if (breakingSchemaChangeCount) {
                            throw new Error(breakingChangesErrorMessage);
                        }
                    }
                }
            ], context => ({
                renderer: context.flags.markdown ? "silent" : "default"
            }));
        }
        catch (error) {
            if (error.message !== breakingChangesErrorMessage) {
                throw error;
            }
        }
        const { checkSchemaResult, config, shouldOutputJson, shouldOutputMarkdown } = taskOutput;
        const { service } = config;
        if (!service) {
            throw new Error("Service mising from config. This should have been validated elsewhere");
        }
        if (shouldOutputJson) {
            return this.log(JSON.stringify({
                targetUrl: checkSchemaResult.targetUrl,
                changes: checkSchemaResult.diffToPrevious.changes,
                validationConfig: checkSchemaResult.diffToPrevious.validationConfig
            }, null, 2));
        }
        else if (shouldOutputMarkdown) {
            const serviceName = config.service && config.service.name;
            if (!serviceName) {
                throw new Error("The service name should have been defined in the Apollo config and validated when the config was loaded. Please file an issue if you're seeing this error.");
            }
            return this.log(formatMarkdown({
                checkSchemaResult,
                serviceName,
                tag: config.tag
            }));
        }
        this.log(formatHumanReadable({ checkSchemaResult }));
        if (checkSchemaResult.diffToPrevious.changes.find(({ type }) => type === graphqlTypes_1.ChangeType.FAILURE)) {
            this.exit(1);
        }
    }
}
ServiceCheck.aliases = ["schema:check"];
ServiceCheck.description = "Check a service against known operation workloads to find breaking changes";
ServiceCheck.flags = Object.assign({}, Command_1.ProjectCommand.flags, { tag: command_1.flags.string({
        char: "t",
        description: "The published tag to check this service against"
    }), validationPeriod: command_1.flags.string({
        description: "The size of the time window with which to validate the schema against. You may provide a number (in seconds), or an ISO8601 format duration for more granularity (see: https://en.wikipedia.org/wiki/ISO_8601#Durations)"
    }), queryCountThreshold: command_1.flags.integer({
        description: "Minimum number of requests within the requested time window for a query to be considered."
    }), queryCountThresholdPercentage: command_1.flags.integer({
        description: "Number of requests within the requested time window for a query to be considered, relative to total request count. Expected values are between 0 and 0.05 (minimum 5% of total request volume)"
    }), json: command_1.flags.boolean({
        description: "Output result in json, which can then be parsed by CLI tools such as jq.",
        exclusive: ["markdown"]
    }), markdown: command_1.flags.boolean({
        description: "Output result in markdown.",
        exclusive: ["json"]
    }) });
exports.default = ServiceCheck;
//# sourceMappingURL=check.js.map