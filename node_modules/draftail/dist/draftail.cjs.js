'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var draftJs = require('draft-js');
var isSoftNewlineEvent = _interopDefault(require('draft-js/lib/isSoftNewlineEvent'));
var draftjsFilters = require('draftjs-filters');
var draftjsConductor = require('draftjs-conductor');
var React = require('react');
var React__default = _interopDefault(React);

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

var BLOCK_TYPE = {
  // This is used to represent a normal text block (paragraph).
  UNSTYLED: "unstyled",
  HEADER_ONE: "header-one",
  HEADER_TWO: "header-two",
  HEADER_THREE: "header-three",
  HEADER_FOUR: "header-four",
  HEADER_FIVE: "header-five",
  HEADER_SIX: "header-six",
  UNORDERED_LIST_ITEM: "unordered-list-item",
  ORDERED_LIST_ITEM: "ordered-list-item",
  BLOCKQUOTE: "blockquote",
  CODE: "code-block",
  // This represents a "custom" block, not for rich text, with arbitrary content.
  ATOMIC: "atomic"
};
var ENTITY_TYPE = {
  LINK: "LINK",
  IMAGE: "IMAGE",
  HORIZONTAL_RULE: "HORIZONTAL_RULE"
}; // See https://github.com/facebook/draft-js/blob/master/src/model/immutable/DefaultDraftInlineStyle.js

var INLINE_STYLE = {
  BOLD: "BOLD",
  ITALIC: "ITALIC",
  CODE: "CODE",
  UNDERLINE: "UNDERLINE",
  STRIKETHROUGH: "STRIKETHROUGH",
  MARK: "MARK",
  QUOTATION: "QUOTATION",
  SMALL: "SMALL",
  SAMPLE: "SAMPLE",
  INSERT: "INSERT",
  DELETE: "DELETE",
  KEYBOARD: "KEYBOARD",
  SUPERSCRIPT: "SUPERSCRIPT",
  SUBSCRIPT: "SUBSCRIPT"
};
var BLOCK_TYPES = Object.values(BLOCK_TYPE);
var ENTITY_TYPES = Object.values(ENTITY_TYPE);
var INLINE_STYLES = Object.values(INLINE_STYLE);
var FONT_FAMILY_MONOSPACE = "Consolas, Menlo, Monaco, Lucida Console, Liberation Mono, DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New, monospace, sans-serif"; // See https://github.com/facebook/draft-js/blob/master/src/model/immutable/DefaultDraftInlineStyle.js

var CUSTOM_STYLE_MAP = {};
CUSTOM_STYLE_MAP[INLINE_STYLE.BOLD] = draftJs.DefaultDraftInlineStyle[INLINE_STYLE.BOLD];
CUSTOM_STYLE_MAP[INLINE_STYLE.ITALIC] = draftJs.DefaultDraftInlineStyle[INLINE_STYLE.ITALIC];
CUSTOM_STYLE_MAP[INLINE_STYLE.STRIKETHROUGH] = draftJs.DefaultDraftInlineStyle[INLINE_STYLE.STRIKETHROUGH];
CUSTOM_STYLE_MAP[INLINE_STYLE.UNDERLINE] = draftJs.DefaultDraftInlineStyle[INLINE_STYLE.UNDERLINE];
CUSTOM_STYLE_MAP[INLINE_STYLE.CODE] = {
  padding: "0.2em 0.3125em",
  margin: "0",
  fontSize: "85%",
  backgroundColor: "rgba(27, 31, 35, 0.05)",
  fontFamily: FONT_FAMILY_MONOSPACE,
  borderRadius: "3px"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.MARK] = {
  backgroundColor: "yellow"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.QUOTATION] = {
  fontStyle: "italic"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SMALL] = {
  fontSize: "smaller"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SAMPLE] = {
  fontFamily: FONT_FAMILY_MONOSPACE
};
CUSTOM_STYLE_MAP[INLINE_STYLE.INSERT] = {
  textDecoration: "underline"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.DELETE] = {
  textDecoration: "line-through"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.KEYBOARD] = {
  fontFamily: FONT_FAMILY_MONOSPACE,
  padding: "3px 5px",
  fontSize: "11px",
  lineHeight: "10px",
  color: "#444d56",
  verticalAlign: "middle",
  backgroundColor: "#fafbfc",
  border: "solid 1px #c6cbd1",
  borderBottomColor: "#959da5",
  borderRadius: "3px",
  boxShadow: "inset 0 -1px 0 #959da5"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SUPERSCRIPT] = {
  fontSize: "80%",
  verticalAlign: "super",
  lineHeight: "1"
};
CUSTOM_STYLE_MAP[INLINE_STYLE.SUBSCRIPT] = {
  fontSize: "80%",
  verticalAlign: "sub",
  lineHeight: "1"
};
var BR_TYPE = "BR";
var UNDO_TYPE = "undo";
var REDO_TYPE = "redo"; // Originally from https://github.com/facebook/draft-js/blob/master/src/component/utils/getDefaultKeyBinding.js.

var KEY_CODES = {
  K: 75,
  B: 66,
  U: 85,
  J: 74,
  I: 73,
  X: 88,
  "0": 48,
  "1": 49,
  "2": 50,
  "3": 51,
  "4": 52,
  "5": 53,
  "6": 54,
  "7": 55,
  "8": 56,
  ".": 190,
  ",": 188
};
var INPUT_BLOCK_MAP = {
  "* ": BLOCK_TYPE.UNORDERED_LIST_ITEM,
  "- ": BLOCK_TYPE.UNORDERED_LIST_ITEM,
  "1. ": BLOCK_TYPE.ORDERED_LIST_ITEM,
  "# ": BLOCK_TYPE.HEADER_ONE,
  "## ": BLOCK_TYPE.HEADER_TWO,
  "### ": BLOCK_TYPE.HEADER_THREE,
  "#### ": BLOCK_TYPE.HEADER_FOUR,
  "##### ": BLOCK_TYPE.HEADER_FIVE,
  "###### ": BLOCK_TYPE.HEADER_SIX,
  "> ": BLOCK_TYPE.BLOCKQUOTE,
  // It makes more sense not to require a space here.
  // This matches how Dropbox Paper operates.
  "```": BLOCK_TYPE.CODE
};
var INPUT_ENTITY_MAP = {};
INPUT_ENTITY_MAP[ENTITY_TYPE.HORIZONTAL_RULE] = "---";
var LABELS = {};
LABELS[BLOCK_TYPE.UNSTYLED] = "P";
LABELS[BLOCK_TYPE.HEADER_ONE] = "H1";
LABELS[BLOCK_TYPE.HEADER_TWO] = "H2";
LABELS[BLOCK_TYPE.HEADER_THREE] = "H3";
LABELS[BLOCK_TYPE.HEADER_FOUR] = "H4";
LABELS[BLOCK_TYPE.HEADER_FIVE] = "H5";
LABELS[BLOCK_TYPE.HEADER_SIX] = "H6";
LABELS[BLOCK_TYPE.UNORDERED_LIST_ITEM] = "UL";
LABELS[BLOCK_TYPE.ORDERED_LIST_ITEM] = "OL";
LABELS[BLOCK_TYPE.CODE] = "{ }";
LABELS[BLOCK_TYPE.BLOCKQUOTE] = "‚ùù";
LABELS[INLINE_STYLE.BOLD] = "B";
LABELS[INLINE_STYLE.ITALIC] = "ùòê";
LABELS[INLINE_STYLE.CODE] = "{ }";
LABELS[INLINE_STYLE.UNDERLINE] = "U";
LABELS[INLINE_STYLE.STRIKETHROUGH] = "S";
LABELS[INLINE_STYLE.MARK] = "‚òÜ";
LABELS[INLINE_STYLE.QUOTATION] = "‚ùõ";
LABELS[INLINE_STYLE.SMALL] = "ùñ≤ùóÜaùóÖùóÖ";
LABELS[INLINE_STYLE.SAMPLE] = "ùô≥ùöäùöùùöä";
LABELS[INLINE_STYLE.INSERT] = "Ins";
LABELS[INLINE_STYLE.DELETE] = "Del";
LABELS[INLINE_STYLE.SUPERSCRIPT] = "Sup";
LABELS[INLINE_STYLE.SUBSCRIPT] = "Sub";
LABELS[INLINE_STYLE.KEYBOARD] = "‚åò";
LABELS[ENTITY_TYPE.LINK] = "üîó";
LABELS[ENTITY_TYPE.IMAGE] = "üñº";
LABELS[ENTITY_TYPE.HORIZONTAL_RULE] = "‚Äï";
LABELS[BR_TYPE] = "‚Üµ";
LABELS[UNDO_TYPE] = "‚Ü∫";
LABELS[REDO_TYPE] = "‚Üª";
var DESCRIPTIONS = {};
DESCRIPTIONS[BLOCK_TYPE.UNSTYLED] = "Paragraph";
DESCRIPTIONS[BLOCK_TYPE.HEADER_ONE] = "Heading 1";
DESCRIPTIONS[BLOCK_TYPE.HEADER_TWO] = "Heading 2";
DESCRIPTIONS[BLOCK_TYPE.HEADER_THREE] = "Heading 3";
DESCRIPTIONS[BLOCK_TYPE.HEADER_FOUR] = "Heading 4";
DESCRIPTIONS[BLOCK_TYPE.HEADER_FIVE] = "Heading 5";
DESCRIPTIONS[BLOCK_TYPE.HEADER_SIX] = "Heading 6";
DESCRIPTIONS[BLOCK_TYPE.UNORDERED_LIST_ITEM] = "Bulleted list";
DESCRIPTIONS[BLOCK_TYPE.ORDERED_LIST_ITEM] = "Numbered list";
DESCRIPTIONS[BLOCK_TYPE.BLOCKQUOTE] = "Blockquote";
DESCRIPTIONS[BLOCK_TYPE.CODE] = "Code block";
DESCRIPTIONS[INLINE_STYLE.BOLD] = "Bold";
DESCRIPTIONS[INLINE_STYLE.ITALIC] = "Italic";
DESCRIPTIONS[INLINE_STYLE.CODE] = "Code";
DESCRIPTIONS[INLINE_STYLE.UNDERLINE] = "Underline";
DESCRIPTIONS[INLINE_STYLE.STRIKETHROUGH] = "Strikethrough";
DESCRIPTIONS[INLINE_STYLE.MARK] = "Highlight";
DESCRIPTIONS[INLINE_STYLE.QUOTATION] = "Inline quotation";
DESCRIPTIONS[INLINE_STYLE.SMALL] = "Small";
DESCRIPTIONS[INLINE_STYLE.SAMPLE] = "Program output";
DESCRIPTIONS[INLINE_STYLE.INSERT] = "Inserted";
DESCRIPTIONS[INLINE_STYLE.DELETE] = "Deleted";
DESCRIPTIONS[INLINE_STYLE.KEYBOARD] = "Shortcut key";
DESCRIPTIONS[INLINE_STYLE.SUPERSCRIPT] = "Superscript";
DESCRIPTIONS[INLINE_STYLE.SUBSCRIPT] = "Subscript";
DESCRIPTIONS[ENTITY_TYPE.LINK] = "Link";
DESCRIPTIONS[ENTITY_TYPE.IMAGE] = "Image";
DESCRIPTIONS[ENTITY_TYPE.HORIZONTAL_RULE] = "Horizontal line";
DESCRIPTIONS[BR_TYPE] = "Line break";
DESCRIPTIONS[UNDO_TYPE] = "Undo";
DESCRIPTIONS[REDO_TYPE] = "Redo";
var KEYBOARD_SHORTCUTS = {};
KEYBOARD_SHORTCUTS[BLOCK_TYPE.UNSTYLED] = "‚å´";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_ONE] = "#";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_TWO] = "##";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_THREE] = "###";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_FOUR] = "####";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_FIVE] = "#####";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.HEADER_SIX] = "######";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.UNORDERED_LIST_ITEM] = "-";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.ORDERED_LIST_ITEM] = "1.";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.BLOCKQUOTE] = ">";
KEYBOARD_SHORTCUTS[BLOCK_TYPE.CODE] = "```";
KEYBOARD_SHORTCUTS[INLINE_STYLE.BOLD] = {
  other: "Ctrl + B",
  macOS: "‚åò + B"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.ITALIC] = {
  other: "Ctrl + I",
  macOS: "‚åò + I"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.UNDERLINE] = {
  other: "Ctrl + U",
  macOS: "‚åò + U"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.STRIKETHROUGH] = {
  other: "Ctrl + ‚áß + X",
  macOS: "‚åò + ‚áß + X"
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.SUPERSCRIPT] = {
  other: "Ctrl + .",
  macOS: "‚åò + ."
};
KEYBOARD_SHORTCUTS[INLINE_STYLE.SUBSCRIPT] = {
  other: "Ctrl + ,",
  macOS: "‚åò + ,"
};
KEYBOARD_SHORTCUTS[ENTITY_TYPE.LINK] = {
  other: "Ctrl + K",
  macOS: "‚åò + K"
};
KEYBOARD_SHORTCUTS[BR_TYPE] = "‚áß + ‚Üµ";
KEYBOARD_SHORTCUTS[ENTITY_TYPE.HORIZONTAL_RULE] = "- - -";
KEYBOARD_SHORTCUTS[UNDO_TYPE] = {
  other: "Ctrl + Z",
  macOS: "‚åò + Z"
};
KEYBOARD_SHORTCUTS[REDO_TYPE] = {
  other: "Ctrl + ‚áß + Z",
  macOS: "‚åò + ‚áß + Z"
};
var HANDLED = "handled";
var NOT_HANDLED = "not-handled";

/**
 * Inspired by draftjs-utils, with our custom functions.
 *
 * DraftUtils functions are utility helpers useful in isolation, specific to the Draft.js API,
 * without ties to Draftail's specific behavior or other APIs.
 */

var DraftUtils = {
  /**
   * Returns the first selected block.
   */
  getSelectedBlock: function getSelectedBlock(editorState) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    return content.getBlockMap().get(selection.getStartKey());
  },

  /**
   * Returns the entity applicable to whole of current selection.
   * An entity can not span multiple blocks.
   * https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/inline.js#L75
   */
  getSelectionEntity: function getSelectionEntity(editorState) {
    var entity;
    var selection = editorState.getSelection();
    var start = selection.getStartOffset();
    var end = selection.getEndOffset();

    if (start === end && start === 0) {
      end = 1;
    } else if (start === end) {
      start -= 1;
    }

    var block = this.getSelectedBlock(editorState);

    for (var i = start; i < end; i += 1) {
      var currentEntity = block.getEntityAt(i);

      if (!currentEntity) {
        entity = undefined;
        break;
      }

      if (i === start) {
        entity = currentEntity;
      } else if (entity !== currentEntity) {
        entity = undefined;
        break;
      }
    }

    return entity;
  },

  /**
   * Creates a selection on a given entity in the currently selected block.
   * Returns the current selection if no entity key is provided, or if the entity could not be found.
   */
  getEntitySelection: function getEntitySelection(editorState, entityKey) {
    var selection = editorState.getSelection();

    if (!entityKey) {
      return selection;
    }

    var block = this.getSelectedBlock(editorState);
    var entityRange; // https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/inline.js#L111

    block.findEntityRanges(function (value) {
      return value.get("entity") === entityKey;
    }, function (start, end) {
      entityRange = {
        start: start,
        end: end
      };
    });

    if (!entityRange) {
      return selection;
    }

    return selection.merge({
      anchorOffset: selection.isBackward ? entityRange.end : entityRange.start,
      focusOffset: selection.isBackward ? entityRange.start : entityRange.end
    });
  },

  /**
   * Updates a given atomic block's entity, merging new data with the old one.
   */
  updateBlockEntity: function updateBlockEntity(editorState, block, data) {
    var content = editorState.getCurrentContent();
    var nextContent = content.mergeEntityData(block.getEntityAt(0), data); // To remove in Draft.js 0.11.
    // This is necessary because entity data is still using a mutable, global store.

    nextContent = draftJs.Modifier.mergeBlockData(nextContent, new draftJs.SelectionState({
      anchorKey: block.getKey(),
      anchorOffset: 0,
      focusKey: block.getKey(),
      focusOffset: block.getLength()
    }), {});
    return draftJs.EditorState.push(editorState, nextContent, "apply-entity");
  },

  /**
   * Inserts a horizontal rule in the place of the current selection.
   * Returns updated EditorState.
   * Inspired by DraftUtils.addLineBreakRemovingSelection.
   */
  addHorizontalRuleRemovingSelection: function addHorizontalRuleRemovingSelection(editorState) {
    var contentState = editorState.getCurrentContent();
    var contentStateWithEntity = contentState.createEntity( // Draft.js Flow typing issue.
    // See https://github.com/facebook/draft-js/issues/868.
    // $FlowFixMe
    ENTITY_TYPE.HORIZONTAL_RULE, "IMMUTABLE", {});
    var entityKey = contentStateWithEntity.getLastCreatedEntityKey();
    return draftJs.AtomicBlockUtils.insertAtomicBlock(editorState, entityKey, " ");
  },

  /**
   * Changes a block type to be `newType`, setting its new text.
   * Also removes the required characters from the characterList,
   * and resets block data.
   */
  resetBlockWithType: function resetBlockWithType(editorState, newType, newText) {
    var contentState = editorState.getCurrentContent();
    var selectionState = editorState.getSelection();
    var key = selectionState.getStartKey();
    var blockMap = contentState.getBlockMap();
    var block = blockMap.get(key); // Maintain persistence in the list while removing chars from the start.
    // https://github.com/facebook/draft-js/blob/788595984da7c1e00d1071ea82b063ff87140be4/src/model/transaction/removeRangeFromContentState.js#L333

    var chars = block.getCharacterList();
    var startOffset = 0;
    var sliceOffset = block.getText().length - newText.length;

    while (startOffset < sliceOffset) {
      chars = chars.shift();
      startOffset += 1;
    }

    var newBlock = block.merge({
      type: newType,
      text: newText,
      characterList: chars,
      data: {}
    });
    var newContentState = contentState.merge({
      blockMap: blockMap.set(key, newBlock)
    });
    var newSelectionState = selectionState.merge({
      anchorOffset: 0,
      focusOffset: 0
    });
    return draftJs.EditorState.acceptSelection(draftJs.EditorState.set(editorState, {
      currentContent: newContentState
    }), newSelectionState);
  },

  /**
   * Removes the block at the given key.
   */
  removeBlock: function removeBlock(editorState, key) {
    var content = editorState.getCurrentContent();
    var blockMap = content.getBlockMap().remove(key);
    return draftJs.EditorState.set(editorState, {
      currentContent: content.merge({
        blockMap: blockMap
      })
    });
  },

  /**
   * Removes a block-level entity, turning the block into an empty paragraph,
   * and placing the selection on it.
   */
  removeBlockEntity: function removeBlockEntity(editorState, entityKey, blockKey) {
    var newState = editorState;
    var content = editorState.getCurrentContent();
    var blockMap = content.getBlockMap();
    var block = blockMap.get(blockKey);
    var newBlock = block.merge({
      type: BLOCK_TYPE.UNSTYLED,
      text: "",
      // No text = no character list
      characterList: block.getCharacterList().slice(0, 0),
      data: {}
    });
    var newSelection = new draftJs.SelectionState({
      anchorKey: blockKey,
      focusKey: blockKey,
      anchorOffset: 0,
      focusOffset: 0
    });
    var newContent = content.merge({
      blockMap: blockMap.set(blockKey, newBlock)
    });
    newState = draftJs.EditorState.push(newState, newContent, "change-block-type");
    newState = draftJs.EditorState.forceSelection(newState, newSelection);
    return newState;
  },

  /**
   * Handles pressing delete within an atomic block. This can happen when selection is placed on an image.
   * Ideally this should be handled by the built-in RichUtils, but it's not.
   * See https://github.com/wagtail/wagtail/issues/4370.
   */
  handleDeleteAtomic: function handleDeleteAtomic(editorState) {
    var selection = editorState.getSelection();
    var content = editorState.getCurrentContent();
    var key = selection.getAnchorKey();
    var offset = selection.getAnchorOffset();
    var block = content.getBlockForKey(key); // Problematic selection. Pressing delete here would remove the entity, but not the block.

    if (selection.isCollapsed() && block.getType() === BLOCK_TYPE.ATOMIC && offset === 0) {
      return this.removeBlockEntity(editorState, block.getEntityAt(0), key);
    }

    return false;
  },

  /**
   * Get an entity decorator strategy based on the given entity type.
   * This strategy will find all entities of the given type.
   */
  getEntityTypeStrategy: function getEntityTypeStrategy(entityType) {
    var strategy = function strategy(block, callback, contentState) {
      block.findEntityRanges(function (character) {
        var entityKey = character.getEntity();
        return entityKey !== null && contentState.getEntity(entityKey).getType() === entityType;
      }, callback);
    };

    return strategy;
  },

  /**
   * Determines whether the editor should show its placeholder.
   * See https://draftjs.org/docs/api-reference-editor.html#placeholder
   * for details on why this is useful.
   */
  shouldHidePlaceholder: function shouldHidePlaceholder(editorState) {
    var contentState = editorState.getCurrentContent();
    return contentState.hasText() || contentState.getBlockMap().first().getType() !== BLOCK_TYPE.UNSTYLED;
  },

  /**
   * Inserts new unstyled block.
   * Initially inspired from https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/block.js#L153,
   * but changed so that the split + block type reset amounts to
   * only one change in the undo stack.
   */
  insertNewUnstyledBlock: function insertNewUnstyledBlock(editorState) {
    var selection = editorState.getSelection();
    var newContent = draftJs.Modifier.splitBlock(editorState.getCurrentContent(), selection);
    var blockMap = newContent.getBlockMap();
    var blockKey = selection.getStartKey();
    var insertedBlockKey = newContent.getKeyAfter(blockKey);
    var newBlock = blockMap.get(insertedBlockKey).set("type", BLOCK_TYPE.UNSTYLED);
    newContent = newContent.merge({
      blockMap: blockMap.set(insertedBlockKey, newBlock)
    });
    return draftJs.EditorState.push(editorState, newContent, "split-block");
  },

  /**
   * Handles Shift + Enter keypress removing selection and inserting a line break.
   * https://github.com/jpuri/draftjs-utils/blob/112bbe449cc9156522fcf2b40f2910a071b795c2/js/block.js#L133
   */
  addLineBreak: function addLineBreak(editorState) {
    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();

    if (selection.isCollapsed()) {
      return draftJs.RichUtils.insertSoftNewline(editorState);
    }

    var newContent = draftJs.Modifier.removeRange(content, selection, "forward");
    var fragment = newContent.getSelectionAfter();
    var block = newContent.getBlockForKey(fragment.getStartKey());
    newContent = draftJs.Modifier.insertText(newContent, fragment, "\n", block.getInlineStyleAt(fragment.getStartOffset()), null);
    return draftJs.EditorState.push(editorState, newContent, "insert-fragment");
  },

  /**
   * Handles hard newlines.
   * https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/keyPress.js#L17
   */
  handleHardNewline: function handleHardNewline(editorState) {
    var selection = editorState.getSelection();

    if (!selection.isCollapsed()) {
      return false;
    }

    var content = editorState.getCurrentContent();
    var blockKey = selection.getStartKey();
    var block = content.getBlockForKey(blockKey);
    var blockType = block.getType();
    var isListBlock = [BLOCK_TYPE.UNORDERED_LIST_ITEM, BLOCK_TYPE.ORDERED_LIST_ITEM].includes(blockType);

    if (!isListBlock && block.getType() !== BLOCK_TYPE.UNSTYLED && block.getLength() === selection.getStartOffset()) {
      return this.insertNewUnstyledBlock(editorState);
    }

    if (isListBlock && block.getLength() === 0) {
      var depth = block.getDepth();

      if (depth === 0) {
        var nextContent = draftJs.RichUtils.tryToRemoveBlockStyle(editorState); // At the moment, tryToRemoveBlockStyle always returns for
        // collapsed selections at the start of a block. So in theory this corner case should never happen.

        return nextContent ? draftJs.EditorState.push(editorState, nextContent, "change-block-type") : false;
      }

      var blockMap = content.getBlockMap();
      var newBlock = block.set("depth", depth - 1);
      return draftJs.EditorState.push(editorState, content.merge({
        blockMap: blockMap.set(blockKey, newBlock)
      }), "adjust-depth");
    }

    return false;
  },

  /**
   * Handles three scenarios:
   * - Soft newlines.
   * - Hard newlines in the "defer breaking out of the block" case.
   * - Other hard newlines.
   * See https://github.com/springload/draftail/issues/104,
   * https://github.com/jpuri/draftjs-utils/issues/10.
   */
  handleNewLine: function handleNewLine(editorState, event) {
    // https://github.com/jpuri/draftjs-utils/blob/e81c0ae19c3b0fdef7e0c1b70d924398956be126/js/keyPress.js#L64
    if (isSoftNewlineEvent(event)) {
      return this.addLineBreak(editorState);
    }

    var content = editorState.getCurrentContent();
    var selection = editorState.getSelection();
    var key = selection.getStartKey();
    var offset = selection.getStartOffset();
    var block = content.getBlockForKey(key);
    var isDeferredBreakoutBlock = [BLOCK_TYPE.CODE].includes(block.getType());

    if (isDeferredBreakoutBlock) {
      var isEmpty = selection.isCollapsed() && offset === 0 && block.getLength() === 0;

      if (isEmpty) {
        return draftJs.EditorState.push(editorState, draftJs.Modifier.setBlockType(content, selection, BLOCK_TYPE.UNSTYLED), "change-block-type");
      }

      return false;
    }

    return this.handleHardNewline(editorState);
  }
};

var hasCommandModifier = draftJs.KeyBindingUtil.hasCommandModifier,
    isOptionKeyCommand = draftJs.KeyBindingUtil.isOptionKeyCommand;
var hasCmd = hasCommandModifier; // Hack relying on the internals of Draft.js.
// See https://github.com/facebook/draft-js/pull/869
// $FlowFixMe

var IS_MAC_OS = isOptionKeyCommand({
  altKey: "test"
}) === "test";
/**
 * Methods defining the behavior of the editor, depending on its configuration.
 */

var behavior = {
  /**
   * Configure block render map from block types list.
   */
  getBlockRenderMap: function getBlockRenderMap(blockTypes) {
    var renderMap = draftJs.DefaultDraftBlockRenderMap; // Override default element for code block.
    // Fix https://github.com/facebook/draft-js/issues/406.

    if (blockTypes.some(function (block) {
      return block.type === BLOCK_TYPE.CODE;
    })) {
      renderMap = renderMap.set(BLOCK_TYPE.CODE, {
        element: "code",
        wrapper: draftJs.DefaultDraftBlockRenderMap.get(BLOCK_TYPE.CODE).wrapper
      });
    }

    blockTypes.filter(function (block) {
      return block.element;
    }).forEach(function (block) {
      renderMap = renderMap.set(block.type, {
        element: block.element
      });
    });
    return renderMap;
  },

  /**
   * block style function automatically adding a class with the block's type.
   */
  blockStyleFn: function blockStyleFn(block) {
    var type = block.getType();
    return "Draftail-block--".concat(type, " ").concat(draftjsConductor.blockDepthStyleFn(block));
  },

  /**
   * Configure key binding function from enabled blocks, styles, entities.
   */
  getKeyBindingFn: function getKeyBindingFn(blockTypes, inlineStyles, entityTypes) {
    var getEnabled = function getEnabled(activeTypes) {
      return activeTypes.reduce(function (enabled, type) {
        enabled[type.type] = type.type;
        return enabled;
      }, {});
    };

    var blocks = getEnabled(blockTypes);
    var styles = getEnabled(inlineStyles);
    var entities = getEnabled(entityTypes); // Emits key commands to use in `handleKeyCommand` in `Editor`.

    var keyBindingFn = function keyBindingFn(e) {
      // Safeguard that we only trigger shortcuts with exact matches.
      // eg. cmd + shift + b should not trigger bold.
      if (e.shiftKey) {
        // Key bindings supported by Draft.js must be explicitely discarded.
        // See https://github.com/facebook/draft-js/issues/941.
        switch (e.keyCode) {
          case KEY_CODES.B:
            return undefined;

          case KEY_CODES.I:
            return undefined;

          case KEY_CODES.J:
            return undefined;

          case KEY_CODES.U:
            return undefined;

          case KEY_CODES.X:
            return hasCmd(e) && styles[INLINE_STYLE.STRIKETHROUGH];

          case KEY_CODES[7]:
            return hasCmd(e) && blocks[BLOCK_TYPE.ORDERED_LIST_ITEM];

          case KEY_CODES[8]:
            return hasCmd(e) && blocks[BLOCK_TYPE.UNORDERED_LIST_ITEM];

          default:
            return draftJs.getDefaultKeyBinding(e);
        }
      }

      var ctrlAlt = (e.ctrlKey || e.metaKey) && e.altKey;

      switch (e.keyCode) {
        case KEY_CODES.K:
          return hasCmd(e) && entities.LINK;

        case KEY_CODES.B:
          return hasCmd(e) && styles[INLINE_STYLE.BOLD];

        case KEY_CODES.I:
          return hasCmd(e) && styles[INLINE_STYLE.ITALIC];

        case KEY_CODES.J:
          return hasCmd(e) && styles[INLINE_STYLE.CODE];

        case KEY_CODES.U:
          return hasCmd(e) && styles[INLINE_STYLE.UNDERLINE];

        case KEY_CODES["."]:
          return hasCmd(e) && styles[INLINE_STYLE.SUPERSCRIPT];

        case KEY_CODES[","]:
          return hasCmd(e) && styles[INLINE_STYLE.SUBSCRIPT];

        case KEY_CODES[0]:
          // Reverting to unstyled block is always available.
          return ctrlAlt && BLOCK_TYPE.UNSTYLED;

        case KEY_CODES[1]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_ONE];

        case KEY_CODES[2]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_TWO];

        case KEY_CODES[3]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_THREE];

        case KEY_CODES[4]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_FOUR];

        case KEY_CODES[5]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_FIVE];

        case KEY_CODES[6]:
          return ctrlAlt && blocks[BLOCK_TYPE.HEADER_SIX];

        default:
          return draftJs.getDefaultKeyBinding(e);
      }
    };

    return keyBindingFn;
  },
  hasKeyboardShortcut: function hasKeyboardShortcut(type) {
    return !!KEYBOARD_SHORTCUTS[type];
  },
  getKeyboardShortcut: function getKeyboardShortcut(type) {
    var isMacOS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : IS_MAC_OS;
    var shortcut = KEYBOARD_SHORTCUTS[type];
    var system = isMacOS ? "macOS" : "other";
    return shortcut && shortcut[system] || shortcut;
  },

  /**
   * Defines whether a block should be altered to a new type when
   * the user types a given mark.
   * This powers the "autolist" feature.
   *
   * Returns the new block type, or false if no replacement should occur.
   */
  handleBeforeInputBlockType: function handleBeforeInputBlockType(mark, blockTypes) {
    return blockTypes.find(function (b) {
      return b.type === INPUT_BLOCK_MAP[mark];
    }) ? INPUT_BLOCK_MAP[mark] : false;
  },
  handleBeforeInputHR: function handleBeforeInputHR(mark, block) {
    return mark === INPUT_ENTITY_MAP[ENTITY_TYPE.HORIZONTAL_RULE] && block.getType() !== BLOCK_TYPE.CODE;
  },
  getCustomStyleMap: function getCustomStyleMap(inlineStyles) {
    var customStyleMap = {};
    inlineStyles.forEach(function (style) {
      if (style.style) {
        customStyleMap[style.type] = style.style;
      } else if (CUSTOM_STYLE_MAP[style.type]) {
        customStyleMap[style.type] = CUSTOM_STYLE_MAP[style.type];
      } else {
        customStyleMap[style.type] = {};
      }
    });
    return customStyleMap;
  },

  /**
   * Applies whitelist and blacklist operations to the editor content,
   * so the resulting editor state is shaped according to Draftail
   * expectations and configuration.
   */
  filterPaste: function filterPaste(_ref, editorState) {
    var maxListNesting = _ref.maxListNesting,
        enableHorizontalRule = _ref.enableHorizontalRule,
        enableLineBreak = _ref.enableLineBreak,
        blockTypes = _ref.blockTypes,
        inlineStyles = _ref.inlineStyles,
        entityTypes = _ref.entityTypes;
    var enabledEntityTypes = entityTypes.slice();
    var whitespacedCharacters = ["\t", "üì∑"];

    if (enableHorizontalRule) {
      enabledEntityTypes.push({
        type: ENTITY_TYPE.HORIZONTAL_RULE
      });
    }

    if (!enableLineBreak) {
      whitespacedCharacters.push("\n");
    }

    return draftjsFilters.filterEditorState({
      blocks: blockTypes.map(function (b) {
        return b.type;
      }),
      styles: inlineStyles.map(function (s) {
        return s.type;
      }),
      entities: enabledEntityTypes,
      maxNesting: maxListNesting,
      whitespacedCharacters: whitespacedCharacters
    }, editorState);
  }
};

var EMPTY_CONTENT_STATE = null;
var conversion = {
  createEditorState: function createEditorState(rawContentState, decorators) {
    // Draft.js flow types are inconsistent with the documented usage of this API.
    // See https://github.com/facebook/draft-js/issues/1585.
    var compositeDecorator = new draftJs.CompositeDecorator(decorators);
    var editorState;

    if (rawContentState) {
      var contentState = draftJs.convertFromRaw(rawContentState);
      editorState = draftJs.EditorState.createWithContent(contentState, compositeDecorator);
    } else {
      editorState = draftJs.EditorState.createEmpty(compositeDecorator);
    }

    return editorState;
  },
  serialiseEditorState: function serialiseEditorState(editorState) {
    var contentState = editorState.getCurrentContent();
    var rawContentState = draftJs.convertToRaw(contentState);
    var isEmpty = rawContentState.blocks.every(function (block) {
      var isEmptyBlock = block.text.trim().length === 0 && (!block.entityRanges || block.entityRanges.length === 0) && (!block.inlineStyleRanges || block.inlineStyleRanges.length === 0);
      return isEmptyBlock;
    });
    return isEmpty ? EMPTY_CONTENT_STATE : rawContentState;
  }
};

/**
 * Wraps a component to provide it with additional props based on context.
 */
var getComponentWrapper = function getComponentWrapper(Wrapped, wrapperProps) {
  var Wrapper = function Wrapper(props) {
    return (// flowlint inexact-spread:off
      React__default.createElement(Wrapped, _extends({}, props, wrapperProps))
    );
  };

  return Wrapper;
};

/**
 * Icon as SVG element. Can optionally render a React element instead.
 */
var Icon = function Icon(_ref) {
  var icon = _ref.icon,
      title = _ref.title,
      className = _ref.className;
  var children;

  if (typeof icon === "string") {
    if (icon.includes("#")) {
      children = React__default.createElement("use", {
        xlinkHref: icon
      });
    } else {
      children = React__default.createElement("path", {
        d: icon
      });
    }
  } else if (Array.isArray(icon)) {
    // eslint-disable-next-line @thibaudcolas/cookbook/react/no-array-index-key
    children = icon.map(function (d, i) {
      return React__default.createElement("path", {
        key: i,
        d: d
      });
    });
  } else {
    return icon;
  }

  return React__default.createElement("svg", {
    width: "16",
    height: "16",
    viewBox: "0 0 1024 1024",
    className: "Draftail-Icon ".concat(className || ""),
    "aria-hidden": title ? null : true,
    role: title ? "img" : null,
    "aria-label": title || null
  }, children);
};

Icon.defaultProps = {
  title: null,
  className: null
};

/**
 * Displays a basic button, with optional active variant,
 * enriched with a tooltip. The tooltip stops showing on click.
 */
var ToolbarButton =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(ToolbarButton, _PureComponent);

  function ToolbarButton(props) {
    var _this;

    _classCallCheck(this, ToolbarButton);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ToolbarButton).call(this, props));
    _this.state = {
      showTooltipOnHover: true
    };
    _this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }
  /* :: onMouseDown: (e: Event) => void; */


  _createClass(ToolbarButton, [{
    key: "onMouseDown",
    value: function onMouseDown(e) {
      var _this$props = this.props,
          name = _this$props.name,
          onClick = _this$props.onClick;
      e.preventDefault();
      this.setState({
        showTooltipOnHover: false
      });

      if (onClick) {
        onClick(name || "");
      }
    }
    /* :: onMouseLeave: () => void; */

  }, {
    key: "onMouseLeave",
    value: function onMouseLeave() {
      this.setState({
        showTooltipOnHover: true
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          name = _this$props2.name,
          active = _this$props2.active,
          label = _this$props2.label,
          title = _this$props2.title,
          icon = _this$props2.icon;
      var showTooltipOnHover = this.state.showTooltipOnHover;
      return React__default.createElement("button", {
        name: name,
        className: "Draftail-ToolbarButton".concat(active ? " Draftail-ToolbarButton--active" : ""),
        type: "button",
        "aria-label": title || null,
        "data-draftail-balloon": title && showTooltipOnHover ? true : null,
        tabIndex: -1,
        onMouseDown: this.onMouseDown,
        onMouseLeave: this.onMouseLeave
      }, typeof icon !== "undefined" && icon !== null ? React__default.createElement(Icon, {
        icon: icon
      }) : null, label ? React__default.createElement("span", {
        className: "Draftail-ToolbarButton__label"
      }, label) : null);
    }
  }]);

  return ToolbarButton;
}(React.PureComponent);

ToolbarButton.defaultProps = {
  name: null,
  active: false,
  label: null,
  title: null,
  icon: null,
  onClick: null
};

var ToolbarGroup = function ToolbarGroup(_ref) {
  var children = _ref.children;
  var hasChildren = React__default.Children.toArray(children).some(function (c) {
    return c !== null;
  });
  return hasChildren ? React__default.createElement("div", {
    className: "Draftail-ToolbarGroup"
  }, children) : null;
};

ToolbarGroup.defaultProps = {
  children: null
};

var getButtonLabel = function getButtonLabel(type, config) {
  var icon = typeof config === "boolean" ? undefined : config.icon;

  if (typeof config.label === "string") {
    return config.label;
  }

  if (typeof icon !== "undefined") {
    return null;
  }

  return LABELS[type];
};

var getButtonTitle = function getButtonTitle(type, config) {
  var description = typeof config === "boolean" || typeof config.description === "undefined" ? DESCRIPTIONS[type] : config.description;
  var hasShortcut = behavior.hasKeyboardShortcut(type);
  var title = description;

  if (hasShortcut) {
    var desc = description ? "".concat(description, "\n") : "";
    title = "".concat(desc).concat(behavior.getKeyboardShortcut(type));
  }

  return title;
};

var ToolbarDefaults =
/*#__PURE__*/
function (_PureComponent) {
  _inherits(ToolbarDefaults, _PureComponent);

  function ToolbarDefaults() {
    _classCallCheck(this, ToolbarDefaults);

    return _possibleConstructorReturn(this, _getPrototypeOf(ToolbarDefaults).apply(this, arguments));
  }

  _createClass(ToolbarDefaults, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          currentStyles = _this$props.currentStyles,
          currentBlock = _this$props.currentBlock,
          blockTypes = _this$props.blockTypes,
          inlineStyles = _this$props.inlineStyles,
          enableHorizontalRule = _this$props.enableHorizontalRule,
          enableLineBreak = _this$props.enableLineBreak,
          showUndoControl = _this$props.showUndoControl,
          showRedoControl = _this$props.showRedoControl,
          entityTypes = _this$props.entityTypes,
          toggleBlockType = _this$props.toggleBlockType,
          toggleInlineStyle = _this$props.toggleInlineStyle,
          addHR = _this$props.addHR,
          addBR = _this$props.addBR,
          onUndoRedo = _this$props.onUndoRedo,
          onRequestSource = _this$props.onRequestSource;
      return [React__default.createElement(ToolbarGroup, {
        key: "styles"
      }, inlineStyles.map(function (t) {
        return React__default.createElement(ToolbarButton, {
          key: t.type,
          name: t.type,
          active: currentStyles.has(t.type),
          label: getButtonLabel(t.type, t),
          title: getButtonTitle(t.type, t),
          icon: t.icon,
          onClick: toggleInlineStyle
        });
      })), React__default.createElement(ToolbarGroup, {
        key: "blocks"
      }, blockTypes.map(function (t) {
        return React__default.createElement(ToolbarButton, {
          key: t.type,
          name: t.type,
          active: currentBlock === t.type,
          label: getButtonLabel(t.type, t),
          title: getButtonTitle(t.type, t),
          icon: t.icon,
          onClick: toggleBlockType
        });
      })), React__default.createElement(ToolbarGroup, {
        key: "hr-br"
      }, enableHorizontalRule ? React__default.createElement(ToolbarButton, {
        name: ENTITY_TYPE.HORIZONTAL_RULE,
        onClick: addHR,
        label: getButtonLabel(ENTITY_TYPE.HORIZONTAL_RULE, enableHorizontalRule),
        title: getButtonTitle(ENTITY_TYPE.HORIZONTAL_RULE, enableHorizontalRule),
        icon: typeof enableHorizontalRule !== "boolean" ? enableHorizontalRule.icon : null
      }) : null, enableLineBreak ? React__default.createElement(ToolbarButton, {
        name: BR_TYPE,
        onClick: addBR,
        label: getButtonLabel(BR_TYPE, enableLineBreak),
        title: getButtonTitle(BR_TYPE, enableLineBreak),
        icon: typeof enableLineBreak !== "boolean" ? enableLineBreak.icon : null
      }) : null), React__default.createElement(ToolbarGroup, {
        key: "entities"
      }, entityTypes.map(function (t) {
        return React__default.createElement(ToolbarButton, {
          key: t.type,
          name: t.type,
          onClick: onRequestSource,
          label: getButtonLabel(t.type, t),
          title: getButtonTitle(t.type, t),
          icon: t.icon
        });
      })), React__default.createElement(ToolbarGroup, {
        key: "undo-redo"
      }, showUndoControl ? React__default.createElement(ToolbarButton, {
        name: UNDO_TYPE,
        onClick: onUndoRedo,
        label: getButtonLabel(UNDO_TYPE, showUndoControl),
        title: getButtonTitle(UNDO_TYPE, showUndoControl)
      }) : null, showRedoControl ? React__default.createElement(ToolbarButton, {
        name: REDO_TYPE,
        onClick: onUndoRedo,
        label: getButtonLabel(REDO_TYPE, showRedoControl),
        title: getButtonTitle(REDO_TYPE, showRedoControl)
      }) : null)];
    }
  }]);

  return ToolbarDefaults;
}(React.PureComponent);

var Toolbar = function Toolbar(props) {
  var controls = props.controls,
      getEditorState = props.getEditorState,
      onChange = props.onChange;
  return React__default.createElement("div", {
    className: "Draftail-Toolbar",
    role: "toolbar"
  }, React__default.createElement(ToolbarDefaults, props), React__default.createElement(ToolbarGroup, null, controls.map(function (Control, i) {
    return React__default.createElement(Control // eslint-disable-next-line @thibaudcolas/cookbook/react/no-array-index-key
    , {
      key: i,
      getEditorState: getEditorState,
      onChange: onChange
    });
  })));
};

/**
 * An <hr/> in the editor.
 */

var DividerBlock = function DividerBlock() {
  return React__default.createElement("hr", {
    className: "Draftail-DividerBlock"
  });
};

var defaultProps = {
  // Initial content of the editor. Use this to edit pre-existing content.
  rawContentState: null,
  // Called when changes occured. Use this to persist editor content.
  onSave: null,
  // Called when the editor receives focus.
  onFocus: null,
  // Called when the editor loses focus.
  onBlur: null,
  // Displayed when the editor is empty. Hidden if the user changes styling.
  placeholder: null,
  // Enable the use of horizontal rules in the editor.
  enableHorizontalRule: false,
  // Enable the use of line breaks in the editor.
  enableLineBreak: false,
  // Show undo control in the toolbar.
  showUndoControl: false,
  // Show redo control in the toolbar.
  showRedoControl: false,
  // Disable copy/paste of rich text in the editor.
  stripPastedStyles: true,
  // Set whether spellcheck is turned on for your editor.
  // See https://draftjs.org/docs/api-reference-editor.html#spellcheck.
  spellCheck: false,
  // Optionally set the overriding text alignment for this editor.
  // See https://draftjs.org/docs/api-reference-editor.html#textalignment.
  textAlignment: null,
  // Optionally set the overriding text directionality for this editor.
  // See https://draftjs.org/docs/api-reference-editor.html#textdirectionality.
  textDirectionality: null,
  // Set if auto capitalization is turned on and how it behaves.
  // See https://draftjs.org/docs/api-reference-editor.html#autocapitalize-string.
  autoCapitalize: null,
  // Set if auto complete is turned on and how it behaves.
  // See https://draftjs.org/docs/api-reference-editor.html#autocomplete-string.
  autoComplete: null,
  // Set if auto correct is turned on and how it behaves.
  // See https://draftjs.org/docs/api-reference-editor.html#autocorrect-string.
  autoCorrect: null,
  // See https://draftjs.org/docs/api-reference-editor.html#aria-props.
  ariaDescribedBy: null,
  // List of the available block types.
  blockTypes: [],
  // List of the available inline styles.
  inlineStyles: [],
  // List of the available entity types.
  entityTypes: [],
  // List of active decorators.
  decorators: [],
  // List of extra toolbar controls.
  controls: [],
  // Max level of nesting for list items. 0 = no nesting. Maximum = 10.
  maxListNesting: 1,
  // Frequency at which to call the save callback (ms).
  stateSaveInterval: 250
};

/* :: import type { ElementRef, Node } from "react"; */

/**
 * Main component of the Draftail editor.
 * Contains the Draft.js editor instance, and ties together UI and behavior.
 */
var DraftailEditor =
/*#__PURE__*/
function (_Component) {
  _inherits(DraftailEditor, _Component);

  /* :: editorRef: ElementRef<Editor>; */

  /* :: copySource: { unregister: () => void }; */

  /* :: updateTimeout: ?number; */

  /* :: lockEditor: () => void; */

  /* :: unlockEditor: () => void; */
  function DraftailEditor(props) {
    var _this;

    _classCallCheck(this, DraftailEditor);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DraftailEditor).call(this, props));
    _this.onChange = _this.onChange.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.saveState = _this.saveState.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.getEditorState = _this.getEditorState.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggleSource = _this.toggleSource.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggleEditor = _this.toggleEditor.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.lockEditor = _this.toggleEditor.bind(_assertThisInitialized(_assertThisInitialized(_this)), true);
    _this.unlockEditor = _this.toggleEditor.bind(_assertThisInitialized(_assertThisInitialized(_this)), false);
    _this.handleReturn = _this.handleReturn.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onFocus = _this.onFocus.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onBlur = _this.onBlur.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onTab = _this.onTab.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleKeyCommand = _this.handleKeyCommand.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleBeforeInput = _this.handleBeforeInput.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handlePastedText = _this.handlePastedText.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggleBlockType = _this.toggleBlockType.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.toggleInlineStyle = _this.toggleInlineStyle.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onEditEntity = _this.onEditEntity.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onRemoveEntity = _this.onRemoveEntity.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.addHR = _this.addHR.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.addBR = _this.addBR.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onUndoRedo = _this.onUndoRedo.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.blockRenderer = _this.blockRenderer.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onRequestSource = _this.onRequestSource.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onCompleteSource = _this.onCompleteSource.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.onCloseSource = _this.onCloseSource.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.focus = _this.focus.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.renderSource = _this.renderSource.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    var rawContentState = props.rawContentState,
        decorators = props.decorators,
        entityTypes = props.entityTypes;
    var entityDecorators = entityTypes.filter(function (type) {
      return !!type.decorator;
    }).map(function (type) {
      return {
        strategy: DraftUtils.getEntityTypeStrategy(type.type),
        // $FlowFixMe
        component: getComponentWrapper(type.decorator, {
          onEdit: _this.onEditEntity,
          onRemove: _this.onRemoveEntity
        })
      };
    });
    _this.state = {
      editorState: conversion.createEditorState(rawContentState, decorators.concat(entityDecorators)),
      hasFocus: false,
      readOnly: false,
      sourceOptions: null
    };
    return _this;
  }

  _createClass(DraftailEditor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.copySource = draftjsConductor.registerCopySource(this.editorRef);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.copySource.unregister();
    }
    /* :: onFocus: () => void; */

  }, {
    key: "onFocus",
    value: function onFocus() {
      this.setState({
        hasFocus: true
      });
      var onFocus = this.props.onFocus;

      if (onFocus) {
        onFocus();
      }
    }
    /* :: onBlur: () => void; */

  }, {
    key: "onBlur",
    value: function onBlur() {
      this.setState({
        hasFocus: false
      });
      var onBlur = this.props.onBlur;

      if (onBlur) {
        onBlur();
      }
    }
    /* :: onTab: (event: SyntheticKeyboardEvent<>) => true; */

  }, {
    key: "onTab",
    value: function onTab(event) {
      var maxListNesting = this.props.maxListNesting;
      var editorState = this.state.editorState;
      var newState = draftJs.RichUtils.onTab(event, editorState, maxListNesting);
      this.onChange(newState);
      return true;
    }
    /* :: onChange: (nextState: EditorState) => void; */

  }, {
    key: "onChange",
    value: function onChange(nextState) {
      var _this2 = this;

      var _this$props = this.props,
          stateSaveInterval = _this$props.stateSaveInterval,
          maxListNesting = _this$props.maxListNesting,
          enableHorizontalRule = _this$props.enableHorizontalRule,
          enableLineBreak = _this$props.enableLineBreak,
          blockTypes = _this$props.blockTypes,
          inlineStyles = _this$props.inlineStyles,
          entityTypes = _this$props.entityTypes;
      var editorState = this.state.editorState;
      var shouldFilterPaste = nextState.getCurrentContent() !== editorState.getCurrentContent() && nextState.getLastChangeType() === "insert-fragment";
      var filteredState = nextState;

      if (shouldFilterPaste) {
        filteredState = behavior.filterPaste({
          maxListNesting: maxListNesting,
          enableHorizontalRule: enableHorizontalRule,
          enableLineBreak: enableLineBreak,
          blockTypes: blockTypes,
          inlineStyles: inlineStyles,
          entityTypes: entityTypes
        }, filteredState);
      }

      this.setState({
        editorState: filteredState
      }, function () {
        window.clearTimeout(_this2.updateTimeout);
        _this2.updateTimeout = window.setTimeout(_this2.saveState, stateSaveInterval);
      });
    }
    /* :: onEditEntity: (entityKey: string) => void; */

  }, {
    key: "onEditEntity",
    value: function onEditEntity(entityKey) {
      var entityTypes = this.props.entityTypes;
      var editorState = this.state.editorState;
      var content = editorState.getCurrentContent();
      var entity = content.getEntity(entityKey);
      var entityType = entityTypes.find(function (t) {
        return t.type === entity.type;
      }); // $FlowFixMe

      if (!entityType.block) {
        var entitySelection = DraftUtils.getEntitySelection(editorState, entityKey);
        var nextState = draftJs.EditorState.acceptSelection(editorState, entitySelection);
        this.onChange(nextState);
      }

      this.toggleSource(entity.getType(), entityKey, entity);
    }
    /* :: onRemoveEntity: (entityKey: string, blockKey: string) => void; */

  }, {
    key: "onRemoveEntity",
    value: function onRemoveEntity(entityKey, blockKey) {
      var entityTypes = this.props.entityTypes;
      var editorState = this.state.editorState;
      var content = editorState.getCurrentContent();
      var entity = content.getEntity(entityKey);
      var entityType = entityTypes.find(function (t) {
        return t.type === entity.type;
      });
      var newState = editorState; // $FlowFixMe

      if (entityType.block) {
        newState = DraftUtils.removeBlockEntity(newState, entityKey, blockKey);
      } else {
        var entitySelection = DraftUtils.getEntitySelection(editorState, entityKey);
        newState = draftJs.RichUtils.toggleLink(newState, entitySelection, null);
      }

      this.onChange(newState);
    }
    /* :: onUndoRedo: (type: string) => void; */

  }, {
    key: "onUndoRedo",
    value: function onUndoRedo(type) {
      var editorState = this.state.editorState;
      var newEditorState = editorState;

      if (type === UNDO_TYPE) {
        newEditorState = draftJs.EditorState.undo(editorState);
      } else if (type === REDO_TYPE) {
        newEditorState = draftJs.EditorState.redo(editorState);
      }

      this.onChange(newEditorState);
    }
    /* :: onRequestSource: (entityType: string) => void; */

  }, {
    key: "onRequestSource",
    value: function onRequestSource(entityType) {
      var editorState = this.state.editorState;
      var contentState = editorState.getCurrentContent();
      var entityKey = DraftUtils.getSelectionEntity(editorState);
      this.toggleSource(entityType, entityKey, entityKey ? contentState.getEntity(entityKey) : null);
    }
    /* :: onCompleteSource: (nextState: EditorState) => void; */

  }, {
    key: "onCompleteSource",
    value: function onCompleteSource(nextState) {
      var _this3 = this;

      this.setState({
        sourceOptions: null
      }, function () {
        if (nextState) {
          _this3.onChange(nextState);
        }

        window.setTimeout(function () {
          _this3.setState({
            readOnly: false
          }, function () {
            window.setTimeout(function () {
              _this3.focus();
            }, 0);
          });
        }, 0);
      });
    }
    /* :: onCloseSource: () => void; */

  }, {
    key: "onCloseSource",
    value: function onCloseSource() {
      this.setState({
        sourceOptions: null,
        readOnly: false
      });
    }
    /* :: getEditorState: () => EditorState; */

  }, {
    key: "getEditorState",
    value: function getEditorState() {
      var editorState = this.state.editorState;
      return editorState;
    }
    /* :: saveState: () => void; */

  }, {
    key: "saveState",
    value: function saveState() {
      var onSave = this.props.onSave;
      var editorState = this.state.editorState;

      if (onSave) {
        onSave(conversion.serialiseEditorState(editorState));
      }
    }
    /* :: toggleEditor: (readOnly: boolean) => void; */

  }, {
    key: "toggleEditor",
    value: function toggleEditor(readOnly) {
      this.setState({
        readOnly: readOnly
      });
    }
    /* :: toggleSource: (type:string, entityKey: ?string, entity: ?EntityInstance) => void; */

  }, {
    key: "toggleSource",
    value: function toggleSource(type, entityKey, entity) {
      var entityTypes = this.props.entityTypes;
      var entityType = entityTypes.find(function (item) {
        return item.type === type;
      });
      this.setState({
        readOnly: true,
        sourceOptions: {
          entity: entity,
          entityKey: entityKey,
          entityType: entityType
        }
      });
    }
    /* :: handleReturn: (e: SyntheticKeyboardEvent<>) => void; */

  }, {
    key: "handleReturn",
    value: function handleReturn(e) {
      var enableLineBreak = this.props.enableLineBreak;
      var editorState = this.state.editorState;
      var contentState = editorState.getCurrentContent();
      var ret = false; // alt + enter opens links and other entities with a `url` property.

      if (e.altKey) {
        // Mark the return as handled even if there is no entity.
        // alt + enter should never create a newline anyway.
        ret = true;
        var entityKey = DraftUtils.getSelectionEntity(editorState);

        if (entityKey) {
          var entityData = contentState.getEntity(entityKey).getData();

          if (entityData.url) {
            window.open(entityData.url);
          }
        }
      } else {
        if (!enableLineBreak) {
          // Quick hack to disable soft line breaks.
          e.which = 0;
        }

        var newState = DraftUtils.handleNewLine(editorState, e);

        if (newState) {
          ret = true;
          this.onChange(newState);
        }
      }

      return ret;
    }
    /* :: handleKeyCommand: (command: DraftEditorCommand) => boolean; */

  }, {
    key: "handleKeyCommand",
    value: function handleKeyCommand(command) {
      var editorState = this.state.editorState;

      if (ENTITY_TYPES.includes(command)) {
        this.onRequestSource(command);
        return true;
      }

      if (BLOCK_TYPES.includes(command)) {
        this.toggleBlockType(command);
        return true;
      }

      if (INLINE_STYLES.includes(command)) {
        this.toggleInlineStyle(command);
        return true;
      } // Special case ‚Äì some delete commands on atomic blocks are not covered by RichUtils.


      if (command === "delete") {
        var _newState = DraftUtils.handleDeleteAtomic(editorState);

        if (_newState) {
          this.onChange(_newState);
          return true;
        }
      }

      var newState = draftJs.RichUtils.handleKeyCommand(editorState, command);

      if (newState) {
        this.onChange(newState);
        return true;
      }

      return false;
    }
    /* :: handleBeforeInput: (char: string) => 'handled' | 'not-handled'; */

  }, {
    key: "handleBeforeInput",
    value: function handleBeforeInput(char) {
      var _this$props2 = this.props,
          blockTypes = _this$props2.blockTypes,
          enableHorizontalRule = _this$props2.enableHorizontalRule;
      var editorState = this.state.editorState;
      var selection = editorState.getSelection();

      if (selection.isCollapsed()) {
        var block = DraftUtils.getSelectedBlock(editorState);
        var startOffset = selection.getStartOffset();
        var text = block.getText();
        var beforeBeforeInput = text.slice(0, startOffset);
        var mark = "".concat(beforeBeforeInput).concat(char);
        var newEditorState = editorState;
        var newBlockType = behavior.handleBeforeInputBlockType(mark, blockTypes);

        if (newBlockType) {
          newEditorState = DraftUtils.resetBlockWithType(newEditorState, newBlockType, text.replace(beforeBeforeInput, ""));
        }

        if (enableHorizontalRule && behavior.handleBeforeInputHR(mark, block)) {
          newEditorState = DraftUtils.removeBlock(DraftUtils.addHorizontalRuleRemovingSelection(newEditorState), block.getKey());
        }

        if (newEditorState !== editorState) {
          this.onChange(newEditorState);
          return HANDLED;
        }
      }

      return NOT_HANDLED;
    }
    /* :: handlePastedText: (text: string, html: ?string, editorState: EditorState) => boolean; */

  }, {
    key: "handlePastedText",
    value: function handlePastedText(text, html, editorState) {
      var stripPastedStyles = this.props.stripPastedStyles; // Leave paste handling to Draft.js when stripping styles is desirable.

      if (stripPastedStyles) {
        return false;
      }

      var pastedState = draftjsConductor.handleDraftEditorPastedText(html, editorState);

      if (pastedState) {
        this.onChange(pastedState);
        return true;
      }

      return false;
    }
    /* :: toggleBlockType: (blockType: string) => void; */

  }, {
    key: "toggleBlockType",
    value: function toggleBlockType(blockType) {
      var editorState = this.state.editorState;
      this.onChange(draftJs.RichUtils.toggleBlockType(editorState, blockType));
    }
    /* :: toggleInlineStyle: (inlineStyle: string) => void; */

  }, {
    key: "toggleInlineStyle",
    value: function toggleInlineStyle(inlineStyle) {
      var editorState = this.state.editorState;
      this.onChange(draftJs.RichUtils.toggleInlineStyle(editorState, inlineStyle));
    }
    /* :: addHR: () => void; */

  }, {
    key: "addHR",
    value: function addHR() {
      var editorState = this.state.editorState;
      this.onChange(DraftUtils.addHorizontalRuleRemovingSelection(editorState));
    }
    /* :: addBR: () => void; */

  }, {
    key: "addBR",
    value: function addBR() {
      var editorState = this.state.editorState;
      this.onChange(DraftUtils.addLineBreak(editorState));
    }
    /* :: blockRenderer: (block: ContentBlock) => {}; */

  }, {
    key: "blockRenderer",
    value: function blockRenderer(block) {
      var entityTypes = this.props.entityTypes;
      var editorState = this.state.editorState;
      var contentState = editorState.getCurrentContent();

      if (block.getType() !== BLOCK_TYPE.ATOMIC) {
        return null;
      }

      var entityKey = block.getEntityAt(0);

      if (!entityKey) {
        return {
          editable: false
        };
      }

      var entity = contentState.getEntity(entityKey);
      var isHorizontalRule = entity.type === ENTITY_TYPE.HORIZONTAL_RULE;

      if (isHorizontalRule) {
        return {
          component: DividerBlock,
          editable: false
        };
      }

      var entityType = entityTypes.find(function (t) {
        return t.type === entity.type;
      });
      return {
        // $FlowFixMe
        component: entityType.block,
        editable: false,
        props: {
          // The editorState is available for arbitrary content manipulation.
          editorState: editorState,
          // Current entity to manage.
          entity: entity,
          // Current entityKey to manage.
          entityKey: entityKey,
          // Whole entityType configuration, as provided to the editor.
          entityType: entityType,
          // Make the whole editor read-only, except for the block.
          lockEditor: this.lockEditor,
          // Make the editor editable again.
          unlockEditor: this.unlockEditor,
          // Shorthand to edit entity data.
          onEditEntity: this.onEditEntity.bind(null, entityKey),
          // Shorthand to remove an entity, and the related block.
          onRemoveEntity: this.onRemoveEntity.bind(null, entityKey, block.getKey()),
          // Update the editorState with arbitrary changes.
          onChange: this.onChange
        }
      };
    } // Imperative focus API similar to that of Draft.js.
    // See https://draftjs.org/docs/advanced-topics-managing-focus.html#content.

    /* :: focus: () => void; */

  }, {
    key: "focus",
    value: function focus() {
      this.editorRef.focus();
    }
    /* :: renderSource: () => ?Node; */

  }, {
    key: "renderSource",
    value: function renderSource() {
      var _this$state = this.state,
          editorState = _this$state.editorState,
          sourceOptions = _this$state.sourceOptions;

      if (sourceOptions && sourceOptions.entityType) {
        var Source = sourceOptions.entityType.source;
        return React__default.createElement(Source // The editorState is available for arbitrary content manipulation.
        , {
          editorState: editorState // Takes the updated editorState, or null if there are no changes, and focuses the editor.
          ,
          onComplete: this.onCompleteSource // Closes the source, without focusing the editor again.
          ,
          onClose: this.onCloseSource // Current entity to edit, if any.
          ,
          entity: sourceOptions.entity // Current entityKey to edit, if any.
          ,
          entityKey: sourceOptions.entityKey // Whole entityType configuration, as provided to the editor.
          ,
          entityType: sourceOptions.entityType
        });
      }

      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;

      var _this$props3 = this.props,
          placeholder = _this$props3.placeholder,
          enableHorizontalRule = _this$props3.enableHorizontalRule,
          enableLineBreak = _this$props3.enableLineBreak,
          showUndoControl = _this$props3.showUndoControl,
          showRedoControl = _this$props3.showRedoControl,
          stripPastedStyles = _this$props3.stripPastedStyles,
          spellCheck = _this$props3.spellCheck,
          textAlignment = _this$props3.textAlignment,
          textDirectionality = _this$props3.textDirectionality,
          autoCapitalize = _this$props3.autoCapitalize,
          autoComplete = _this$props3.autoComplete,
          autoCorrect = _this$props3.autoCorrect,
          ariaDescribedBy = _this$props3.ariaDescribedBy,
          blockTypes = _this$props3.blockTypes,
          inlineStyles = _this$props3.inlineStyles,
          entityTypes = _this$props3.entityTypes,
          controls = _this$props3.controls,
          maxListNesting = _this$props3.maxListNesting;
      var _this$state2 = this.state,
          editorState = _this$state2.editorState,
          hasFocus = _this$state2.hasFocus,
          readOnly = _this$state2.readOnly;
      var hidePlaceholder = DraftUtils.shouldHidePlaceholder(editorState);
      return React__default.createElement("div", {
        className: "Draftail-Editor".concat(readOnly ? " Draftail-Editor--readonly" : "").concat(hidePlaceholder ? " Draftail-Editor--hide-placeholder" : "").concat(hasFocus ? " Draftail-Editor--focus" : "")
      }, React__default.createElement(Toolbar, {
        currentStyles: editorState.getCurrentInlineStyle(),
        currentBlock: DraftUtils.getSelectedBlock(editorState).getType(),
        enableHorizontalRule: enableHorizontalRule,
        enableLineBreak: enableLineBreak,
        showUndoControl: showUndoControl,
        showRedoControl: showRedoControl,
        blockTypes: blockTypes,
        inlineStyles: inlineStyles,
        entityTypes: entityTypes,
        controls: controls,
        readOnly: readOnly,
        toggleBlockType: this.toggleBlockType,
        toggleInlineStyle: this.toggleInlineStyle,
        addHR: this.addHR,
        addBR: this.addBR,
        onUndoRedo: this.onUndoRedo,
        onRequestSource: this.onRequestSource,
        getEditorState: this.getEditorState,
        onChange: this.onChange
      }), React__default.createElement(draftJs.Editor, {
        customStyleMap: behavior.getCustomStyleMap(inlineStyles),
        ref: function ref(_ref) {
          _this4.editorRef = _ref;
        },
        editorState: editorState,
        onChange: this.onChange,
        placeholder: placeholder,
        readOnly: readOnly,
        stripPastedStyles: stripPastedStyles,
        spellCheck: spellCheck,
        textAlignment: textAlignment,
        textDirectionality: textDirectionality,
        autoCapitalize: autoCapitalize,
        autoComplete: autoComplete,
        autoCorrect: autoCorrect,
        ariaDescribedBy: ariaDescribedBy,
        handleReturn: this.handleReturn,
        keyBindingFn: behavior.getKeyBindingFn(blockTypes, inlineStyles, entityTypes),
        handleKeyCommand: this.handleKeyCommand,
        handleBeforeInput: this.handleBeforeInput,
        handlePastedText: this.handlePastedText,
        onFocus: this.onFocus,
        onBlur: this.onBlur,
        onTab: this.onTab,
        blockRendererFn: this.blockRenderer,
        blockRenderMap: behavior.getBlockRenderMap(blockTypes),
        blockStyleFn: behavior.blockStyleFn
      }), this.renderSource(), React__default.createElement(draftjsConductor.ListNestingStyles, {
        max: maxListNesting
      }));
    }
  }]);

  return DraftailEditor;
}(React.Component);

DraftailEditor.defaultProps = defaultProps;

/**
 * Draftail's main API entry point. Exposes all of the modules people
 * will need to create their own editor instances from Draftail.
 */

exports.DraftailEditor = DraftailEditor;
exports.Icon = Icon;
exports.ToolbarButton = ToolbarButton;
exports.DraftUtils = DraftUtils;
exports.BLOCK_TYPE = BLOCK_TYPE;
exports.ENTITY_TYPE = ENTITY_TYPE;
exports.INLINE_STYLE = INLINE_STYLE;
