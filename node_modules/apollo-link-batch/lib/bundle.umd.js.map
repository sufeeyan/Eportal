{"version":3,"file":"bundle.umd.js","sources":["../src/batching.ts","../src/batchLink.ts"],"sourcesContent":["import { Observable, Operation, NextLink, FetchResult } from 'apollo-link';\n\nexport type BatchHandler = (\n  operations: Operation[],\n  forward?: (NextLink | undefined)[],\n) => Observable<FetchResult[]> | null;\n\nexport interface BatchableRequest {\n  operation: Operation;\n  forward?: NextLink;\n\n  // promise is created when the query fetch request is\n  // added to the queue and is resolved once the result is back\n  // from the server.\n  observable?: Observable<FetchResult>;\n  next?: Array<(result: FetchResult) => void>;\n  error?: Array<(error: Error) => void>;\n  complete?: Array<() => void>;\n}\n\n// QueryBatcher doesn't fire requests immediately. Requests that were enqueued within\n// a certain amount of time (configurable through `batchInterval`) will be batched together\n// into one query.\nexport class OperationBatcher {\n  // Queue on which the QueryBatcher will operate on a per-tick basis.\n  // Public only for testing\n  public queuedRequests: Map<string, BatchableRequest[]>;\n\n  private batchInterval: number;\n  private batchMax: number;\n\n  //This function is called to the queries in the queue to the server.\n  private batchHandler: BatchHandler;\n  private batchKey: (operation: Operation) => string;\n\n  constructor({\n    batchInterval,\n    batchMax = 0,\n    batchHandler,\n    batchKey = () => '',\n  }: {\n    batchInterval: number;\n    batchMax?: number;\n    batchHandler: BatchHandler;\n    batchKey?: (operation: Operation) => string;\n  }) {\n    this.queuedRequests = new Map();\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax;\n    this.batchHandler = batchHandler;\n    this.batchKey = batchKey;\n  }\n\n  public enqueueRequest(request: BatchableRequest): Observable<FetchResult> {\n    const requestCopy = {\n      ...request,\n    };\n    let queued = false;\n\n    const key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable<FetchResult>(observer => {\n        if (!this.queuedRequests.has(key)) {\n          this.queuedRequests.set(key, []);\n        }\n\n        if (!queued) {\n          this.queuedRequests.get(key).push(requestCopy);\n          queued = true;\n        }\n\n        //called for each subscriber, so need to save all listeners(next, error, complete)\n        requestCopy.next = requestCopy.next || [];\n        if (observer.next) requestCopy.next.push(observer.next.bind(observer));\n\n        requestCopy.error = requestCopy.error || [];\n        if (observer.error)\n          requestCopy.error.push(observer.error.bind(observer));\n\n        requestCopy.complete = requestCopy.complete || [];\n        if (observer.complete)\n          requestCopy.complete.push(observer.complete.bind(observer));\n\n        // The first enqueued request triggers the queue consumption after `batchInterval` milliseconds.\n        if (this.queuedRequests.get(key).length === 1) {\n          this.scheduleQueueConsumption(key);\n        }\n\n        // When amount of requests reaches `batchMax`, trigger the queue consumption without waiting on the `batchInterval`.\n        if (this.queuedRequests.get(key).length === this.batchMax) {\n          this.consumeQueue(key);\n        }\n      });\n    }\n\n    return requestCopy.observable;\n  }\n\n  // Consumes the queue.\n  // Returns a list of promises (one for each query).\n  public consumeQueue(\n    key: string = '',\n  ): (Observable<FetchResult> | undefined)[] | undefined {\n    const queuedRequests = this.queuedRequests.get(key);\n\n    if (!queuedRequests) {\n      return;\n    }\n\n    this.queuedRequests.delete(key);\n\n    const requests: Operation[] = queuedRequests.map(\n      queuedRequest => queuedRequest.operation,\n    );\n\n    const forwards: NextLink[] = queuedRequests.map(\n      queuedRequest => queuedRequest.forward,\n    );\n\n    const observables: (Observable<FetchResult> | undefined)[] = [];\n    const nexts: any[] = [];\n    const errors: any[] = [];\n    const completes: any[] = [];\n    queuedRequests.forEach((batchableRequest, index) => {\n      observables.push(batchableRequest.observable);\n      nexts.push(batchableRequest.next);\n      errors.push(batchableRequest.error);\n      completes.push(batchableRequest.complete);\n    });\n\n    const batchedObservable =\n      this.batchHandler(requests, forwards) || Observable.of();\n\n    const onError = error => {\n      //each callback list in batch\n      errors.forEach(rejecters => {\n        if (rejecters) {\n          //each subscriber to request\n          rejecters.forEach(e => e(error));\n        }\n      });\n    };\n\n    batchedObservable.subscribe({\n      next: results => {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          const error = new Error(\n            `server returned results with length ${\n              results.length\n            }, expected length of ${nexts.length}`,\n          );\n          (error as any).result = results;\n\n          return onError(error);\n        }\n\n        results.forEach((result, index) => {\n          if (nexts[index]) {\n            nexts[index].forEach(next => next(result));\n          }\n        });\n      },\n      error: onError,\n      complete: () => {\n        completes.forEach(complete => {\n          if (complete) {\n            //each subscriber to request\n            complete.forEach(c => c());\n          }\n        });\n      },\n    });\n\n    return observables;\n  }\n\n  private scheduleQueueConsumption(key: string = ''): void {\n    setTimeout(() => {\n      if (this.queuedRequests.get(key) && this.queuedRequests.get(key).length) {\n        this.consumeQueue(key);\n      }\n    }, this.batchInterval);\n  }\n}\n","import {\n  ApolloLink,\n  Operation,\n  FetchResult,\n  Observable,\n  NextLink,\n} from 'apollo-link';\nimport { OperationBatcher, BatchHandler } from './batching';\n\nexport { OperationBatcher, BatchableRequest, BatchHandler } from './batching';\n\nexport namespace BatchLink {\n  export interface Options {\n    /**\n     * The interval at which to batch, in milliseconds.\n     *\n     * Defaults to 10.\n     */\n    batchInterval?: number;\n\n    /**\n     * The maximum number of operations to include in one fetch.\n     *\n     * Defaults to 0 (infinite operations within the interval).\n     */\n    batchMax?: number;\n\n    /**\n     * The handler that should execute a batch of operations.\n     */\n    batchHandler?: BatchHandler;\n\n    /**\n     * creates the key for a batch\n     */\n    batchKey?: (operation: Operation) => string;\n  }\n}\n\nexport class BatchLink extends ApolloLink {\n  private batcher: OperationBatcher;\n\n  constructor(fetchParams: BatchLink.Options = {}) {\n    super();\n\n    const {\n      batchInterval = 10,\n      batchMax = 0,\n      batchHandler = () => null,\n      batchKey = () => '',\n    } = fetchParams;\n\n    this.batcher = new OperationBatcher({\n      batchInterval,\n      batchMax,\n      batchHandler,\n      batchKey,\n    });\n\n    //make this link terminating\n    if (fetchParams.batchHandler.length <= 1) {\n      this.request = operation => this.batcher.enqueueRequest({ operation });\n    }\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    return this.batcher.enqueueRequest({\n      operation,\n      forward,\n    });\n  }\n}\n"],"names":["Observable","ApolloLink"],"mappings":"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"}